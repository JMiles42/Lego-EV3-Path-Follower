#pragma config(Sensor, S3,     ,               sensorEV3_Gyro)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

typedef struct v2d
{
	float X;
	float Y;
} v2d;

void Multiply(v2d* vec, float amount)
{
	vec->X *= amount;
	vec->Y *= amount;
}

//Draws pixels on the screen at the position
void DrawPos(int xPos, int yPos)
{
	const int squareSize = 2;
	drawRect(xPos, yPos, xPos + squareSize, yPos + squareSize);
}

//Draws pixels on the screen at the position
void DrawPos(v2d pos)
{
	DrawPos(pos.X,pos.Y);
}

//GetsNormalizedRotation from the sensors resualt, limits the value to 0 - 359
float GetNormalizedRotation(float gRot)
{
	return (gRot + 360) % 360;
}

//https://stackoverflow.com/questions/34583438/function-deg2rad-could-not-be-resolved
float deg2rad (float deg)
{
	return deg * 4.0 * atan (1.0) / 180.0;
}

//Simply moves the vector in the direction of the velocity
void MovePosInDirectionByVelocity (v2d* pos, v2d vel, float rotation)
{
	float theta = deg2rad(rotation);

	float cs = cos(theta);
	float sn = sin(theta);

	float x = vel.X * cs - vel.Y * sn;
	float y = vel.X * sn + vel.Y * cs;

	pos->X += x;
	pos->Y += y;
}

float lastDist = -1;

task ResetNumber()
{
	while(true)
	{
		waitForButtonPress();
		lastDist =  5;
	}
}

const int SCREEN_WIDTH = 177;
const int SCREEN_HEIGHT = 127;
const int SPEED = 2;

task main()
{
	waitForButtonPress();
	v2d myPos;
	myPos.X = SCREEN_WIDTH / 2;
	myPos.Y = SCREEN_HEIGHT / 2;
	resetGyro(S3);
	DrawPos(myPos);
	lastDist = -1;

	while(true)
	{
		v2d myDir;
		{//Set myDir values			
			myDir.X = 0;
			myDir.Y = 1;
		}

		float realRotation = GetNormalizedRotation(getGyroDegrees(S3));
		DrawPos(myPos);
		float sDist = getUSDistance(S4);

		if(lastDist < 255 && lastDist > 2)
		{
			setMotor(1, SPEED * ((sDist)*0.7));
			setMotor(0, SPEED * ((sDist)*0.7));
			lastDist = sDist;
		}
		else
		{
			stopAllMotors();

			setMotor(0, SPEED * 10);
			setMotor(1, SPEED * -10);
			lastDist = 254;
		}
		Multiply(myDir, 2);
		MovePosInDirectionByVelocity(myPos, myDir, realRotation);
	}
}
