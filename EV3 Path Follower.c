#pragma config(Sensor, S2,     ReverseBtn,     sensorEV3_Touch)
#pragma config(Sensor, S3,     Gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     Eyes,           sensorEV3_Ultrasonic)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//The stored movement mode
typedef enum moveMode
{
    mmNul = 0,
    mmFwd = 1,
    mmBwd = 2,
    mmLft = 3,
    mmRit = 4,
    mmStp = 5
} moveMode;

//Based on Advanced examples linked list struct
//Although after implimenting their example, I chose to remove the memory adresses and just us the array that they also had
//IMPROVEMENTS: Could just use an array of the enum
typedef struct instListElement
{
    moveMode movementMode;
} instListElement;

//A vector of 2 dimensions
typedef struct v2d
{
    float X;
    float Y;
} v2d;

const int kNumbOfListItems = 100;

bool RegisterButtons();
float deg2rad (float deg);
void DrawPathOnScreen();
void DrawPos(int xPos, int yPos);
void DriveMotors(moveMode mvmtMode);
void initList(instListElement *list, int nListSize);
void MoveAlongPath();
void MovePosInDirectionByVelocity (v2d* pos, v2d vel, float rotation);
void RegisterUserDirectionInput(moveMode mode);

const float MAX_BACKWARDS_SPEED = 15;
const float MAX_FORWARD_SPEED = 20;
const float MAX_TURN_SPEED = 15;
const int SCREEN_HEIGHT = 127;
const int SCREEN_WIDTH = 177;

bool isStopped = true;
float bwdSpeed = MAX_BACKWARDS_SPEED;
float fwdSpeed = MAX_FORWARD_SPEED;
float trnSpeed = MAX_TURN_SPEED;
instListElement listElements[kNumbOfListItems];

task main()
{
    //Initilize the Array
    initList(&listElements[0], kNumbOfListItems);
    resetGyro(S3);

    //Loop for the main program to run forever
    while(true)
    {
        float dist = getUSDistance(S4);
        if(dist < 15)
            fwdSpeed = MAX_FORWARD_SPEED * 0.2;
        else
            fwdSpeed = MAX_FORWARD_SPEED;
        //Check for if a button was pressed
        if(RegisterButtons())
        {
            DrawPathOnScreen();
            wait(300, milliseconds);
        }
    }
}

//Drive the motors based on the moveMode passed, and wait a pre deturmined amount of time
void DriveMotors(moveMode mvmtMode)
{
    switch(mvmtMode)
    {
    case mmFwd:
        setMultipleMotors(fwdSpeed, 0, 1);
        wait(200, milliseconds);
        break;
    case mmBwd:
        setMultipleMotors(bwdSpeed, 0, 1);
        wait(200, milliseconds);
        break;
    case mmLft:
        setMotor(0, -trnSpeed);
        setMotor(1, trnSpeed);

        wait(100, milliseconds);
        break;
    case mmRit:
        setMotor(0, trnSpeed);
        setMotor(1, -trnSpeed);
        wait(100, milliseconds);
        break;
    case mmStp:
        setMultipleMotors(0, 0, 1);
        wait(200, milliseconds);
        break;
    case mmNul:
        setMultipleMotors(0, 0, 1);
        wait(200, milliseconds);
        break;
    }
}

//Check if any buttons are pressed
bool RegisterButtons()
{
    if(getButtonPress(buttonLeft) == 1)
        RegisterUserDirectionInput(mmLft);
    else if(getButtonPress(buttonRight) == 1)
        RegisterUserDirectionInput(mmRit);
    else if(getButtonPress(buttonUp) == 1)
        RegisterUserDirectionInput(mmFwd);
    else if(getButtonPress(buttonDown) == 1)
        RegisterUserDirectionInput(mmBwd);
    else if(getButtonPress(buttonEnter) == 1)
    {
        if(isStopped)
        {
            isStopped = false;
            MoveAlongPath();
        }
    }
    else
        return false;
    return true;
}

//Register the users input actions to the queue
void RegisterUserDirectionInput(moveMode mode)
{
    for (int i = 0; i < kNumbOfListItems; ++i)
    {
        instListElement* item = &listElements[i];
        //Find the first null action in the list
        if(item->movementMode == mmNul)
        {
            item->movementMode = mode;
            return;
        }
    }
}

void DrawPathOnScreen()
{
    eraseDisplay();
    //Init the position in space
    v2d vec;
    vec.X = SCREEN_WIDTH / 2;
    vec.Y = SCREEN_HEIGHT / 2;
    float rot = 0;

    for (int i = 0; i < kNumbOfListItems; ++i)
    {
        instListElement* item = &listElements[i];
        //Init velocity of the movement
        v2d vel;
        vel.X = 0;
        vel.Y = 0;
        switch(item->movementMode)
        {
        case mmFwd:
            vel.X = 0;
            vel.Y = 1;
            break;
        case mmBwd:
            vel.X = 0;
            vel.Y = -1;
            break;
        case mmLft:
            rot += 30;
            break;
        case mmRit:
            rot -= 30;
            break;
        case mmStp:
            break;
        case mmNul:
            return;
        }
        displayString(3, "%d", i);

        MovePosInDirectionByVelocity(&vec, vel, rot);
        DrawPos(vec.X, vec.Y);
    }
}

//Draws pixels on the screen at the position
void DrawPos(int xPos, int yPos)
{
    const int squareSize = 2;
    drawRect(xPos, yPos, xPos + squareSize, yPos + squareSize);
}

//Found on, this is used in the MovePosInDirectionByVelocity and would normaly be found in a maths library
//https://stackoverflow.com/questions/34583438/function-deg2rad-could-not-be-resolved
float deg2rad (float deg)
{
    return deg * 4.0 * atan (1.0) / 180.0;
}

//Moves the passed Vector2D position be the velocity and rotation
void MovePosInDirectionByVelocity (v2d* pos, v2d vel, float rotation)
{
    float theta = deg2rad(rotation);

    float cs = cos(theta);
    float sn = sin(theta);

    float x = vel.X * cs - vel.Y * sn;
    float y = vel.X * sn + vel.Y * cs;

    pos->X += x;
    pos->Y += y;
}

//Moves the vehicle along the path
void MoveAlongPath()
{
    for (int i = 0; i < kNumbOfListItems; ++i)
    {
        instListElement* item = &listElements[i];
        DriveMotors(item->movementMode);
    }

    DriveMotors(mmStp);
}

//From Advanced examples Linked List
//Inits the default state of the list and list items
void initList(instListElement *list, int nListSize)
{
    instListElement *pCurr;
    instListElement *pNext;

    memset(list, 99, sizeof(instListElement) * nListSize);
    memset(list, 0, sizeof(instListElement) * nListSize);
    pCurr = list;
    pCurr->movementMode = mmNul;

    pNext = pCurr;
    for (int index = 0; index < nListSize; ++index)
    {
        pCurr = pNext;
        pNext += sizeof(instListElement);  // Kludge until compiler fixed.
        pCurr->movementMode = mmNul;
    }
}