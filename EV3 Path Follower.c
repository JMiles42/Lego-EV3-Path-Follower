#pragma config(Sensor, S3,     Gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S4,     Eyes,           sensorEV3_Ultrasonic)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//The stored movement Action
typedef enum moveAction
{
    //No Action
    mmNoA = 0,
    //Forwards Action
    mmFwd = 1,
    //Backwards Action
    mmBwd = 2,
    //Left Action
    mmLft = 3,
    //Right Action
    mmRit = 4,
    //Stop Action
    mmStp = 5
} moveAction;

//A vector of 2 dimensions
typedef struct vector2D
{
    float X;
    float Y;
} vector2D;

bool CheckForButtonClick();
float deg2rad (float deg);
void DrawPathOnScreen();
void DrawPos(int xPos, int yPos);
void DriveMotors(moveAction mvmtMode);
void Init();
void MainLogic();
void MoveAlongPath();
void MovePosInDirectionByVelocity (vector2D* pos, vector2D vel, float rotation);
void RegisterUserDirectionInput(moveAction mode);
void Rotate();
void initList(moveAction *list, int nListSize);

const float MAX_BACKWARD_SPEED   = 15;
const float MAX_BACKWARD_TIME_MS = 200;
const float MAX_FORWARD_SPEED    = 20;
const float MAX_FORWARD_TIME_MS  = 200;
const float MAX_TRUN_SPEED       = 15;
const float MAX_WAIT_TIME_MS     = 200;
const float TURN_AMOUNT          = 30;
const int ACTION_LIST_LENGTH     = 100;
const int SCREEN_HEIGHT          = 127;
const int SCREEN_WIDTH           = 177;

bool isStopped = true;
float bwdSpeed = MAX_BACKWARD_SPEED;
float fwdSpeed = MAX_FORWARD_SPEED;
float trnSpeed = MAX_TRUN_SPEED;
moveAction actionList[ACTION_LIST_LENGTH];

task main()
{
    Init();
    MainLogic();
}

void Init()
{
    initList(&actionList[0], ACTION_LIST_LENGTH);
    resetGyro(S3);
}

void MainLogic()
{
    //Loop for the main program to run forever
    while(true)
    {
        //Check for if a button was pressed
        if(CheckForButtonClick())//Also executes the action for the buttons
        {
            DrawPathOnScreen();//Updates path on screen
            wait(300, milliseconds); //Quick work around to not have multiple recordings from one press
        }
    }
}

//Drive the motors based on the moveMode passed, and wait a pre deturmined amount of time
void DriveMotors(moveAction mvmtMode)
{
    switch(mvmtMode)
    {
    case mmFwd:
        if(getUSDistance(S4) < 10)
            setMultipleMotors(0, 0, 1);
        else
            setMultipleMotors(fwdSpeed, 0, 1);
        wait(MAX_FORWARD_TIME_MS, milliseconds);
        break;
    case mmBwd:
        setMultipleMotors(bwdSpeed, 0, 1);
        wait(MAX_BACKWARD_TIME_MS, milliseconds);
        break;
    case mmLft:
        Rotate(false, trnSpeed, TURN_AMOUNT);
        break;
    case mmRit:
        Rotate(false, trnSpeed, TURN_AMOUNT);
        break;
    case mmStp:
        setMultipleMotors(0, 0, 1);
        wait(MAX_WAIT_TIME_MS, milliseconds);
        break;
    case mmNoA:
        setMultipleMotors(0, 0, 1);
        wait(MAX_WAIT_TIME_MS, milliseconds);
        break;
    }
}

//Rotates the tracks to turn an amount of degrees
void Rotate(bool left, float speed, float amount)
{
    float initialRotation = getGyroDegrees(S3);

    if(left)
    {
        while((initialRotation - amount) > getGyroDegrees(S3))
        {
            setMotor(0, -trnSpeed);
            setMotor(1, trnSpeed);
        }
    }
    else
    {
        while((initialRotation + amount) < getUSDistance(S4))
        {
            setMotor(0, trnSpeed);
            setMotor(1, -trnSpeed);
        }
    }
}

//Check if any buttons are pressed
bool CheckForButtonClick()
{
    int btnLeft  = getButtonPress(buttonLeft);
    int btnRight = getButtonPress(buttonRight);
    int btnUp    = getButtonPress(buttonUp);
    int btnDown  = getButtonPress(buttonDown);
    int btnEnter = getButtonPress(buttonEnter);

    if(btnLeft == 1)
        RegisterUserDirectionInput(mmLft);
    else if(btnRight == 1)
        RegisterUserDirectionInput(mmRit);
    else ifbtnUp == 1)
        RegisterUserDirectionInput(mmFwd);
    else if(btnDown == 1)
        RegisterUserDirectionInput(mmBwd);
    else if(btnEnter == 1)
    {
        if(isStopped)
        {
            isStopped = false;
            MoveAlongPath();
        }
        else
           isStopped = true;

    }
    else
        return false;

    return true;
    }
}

//Register the users input actions to the queue
void RegisterUserDirectionInput(moveAction mode)
{
    for (int i = 0; i < ACTION_LIST_LENGTH; ++i)
    {
        //Find the first null action in the list
        if(actionList[i].movementMode == mmNoA)
        {
            actionList[i].movementMode = mode;
            return;
        }
    }
}

void DrawPathOnScreen()
{
    eraseDisplay();
    //Init the position in space
    vector2D vec;
    vec.X = SCREEN_WIDTH / 2;
    vec.Y = SCREEN_HEIGHT / 2;
    float rot = 0;

    for (int i = 0; i < ACTION_LIST_LENGTH; ++i)
    {
        //Init velocity of the movement
        vector2D vel;
        vel.X = 0;
        vel.Y = 0;
        switch(actionList[i].movementMode)
        {
        case mmFwd:
            vel.X = 0;
            vel.Y = 1;
            break;
        case mmBwd:
            vel.X = 0;
            vel.Y = -1;
            break;
        case mmLft:
            rot += TURN_AMOUNT;
            break;
        case mmRit:
            rot -= TURN_AMOUNT;
            break;
        case mmStp:
            break;
        case mmNoA:
            return;
        }
        displayString(1, "%d", i);

        MovePosInDirectionByVelocity(&vec, vel, rot);
        DrawPos(vec.X, vec.Y);
    }
}

//Draws pixels on the screen at the position
void DrawPos(int xPos, int yPos)
{
    const int squareSize = 2;
    drawRect(xPos, yPos, xPos + squareSize, yPos + squareSize);
}

//Found on, this is used in the MovePosInDirectionByVelocity and would normaly be found in a maths library
//https://stackoverflow.com/questions/34583438/function-deg2rad-could-not-be-resolved
float deg2rad (float deg)
{
    return deg * 4.0 * atan (1.0) / 180.0;
}

//Moves the passed Vector2D position be the velocity and rotation
void MovePosInDirectionByVelocity (vector2D* pos, vector2D vel, float rotation)
{
    float theta = deg2rad(rotation);

    float cs = cos(theta);
    float sn = sin(theta);

    float x = vel.X * cs - vel.Y * sn;
    float y = vel.X * sn + vel.Y * cs;

    pos->X += x;
    pos->Y += y;
}

//Moves the vehicle along the path
void MoveAlongPath()
{
    for (int i = 0; i < ACTION_LIST_LENGTH; ++i)
        DriveMotors(actionList[i].movementMode);

    DriveMotors(mmStp);
}

//From Advanced examples Linked List
//Inits the default state of the list and list items
void initList(moveAction *list, int nListSize)
{
    moveAction *pCurr;
    moveAction *pNext;

    memset(list, 99, sizeof(moveAction) * nListSize);
    memset(list, 0, sizeof(moveAction) * nListSize);
    pCurr = list;
    *pCurr = mmNoA;

    pNext = pCurr;
    for (int index = 0; index < nListSize; ++index)
    {
        pCurr = pNext;
        pNext += sizeof(moveAction);  // Kludge until compiler fixed.
        *pCurr = mmNoA;
    }
}
